[{"title":"New Date的属性","date":"2017-07-04T07:02:04.000Z","path":"2017/07/04/New-Date的属性/","text":"在写代码用到时间的时候经常记不住获取时、分、秒等的属性怎么写，因此在这里将他们整理出来，方便查询。 时间用法表格 产品 价格 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getYear() 已废弃。 请使用 getFullYear() 方法代替。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setTime() setTime() 方法以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCSeconds() setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。 setYear() 已废弃。请使用 setFullYear() 方法代替。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 已废弃。请使用 toUTCString() 方法代替。 toISOString() 使用 ISO 标准返回字符串的日期格式。 toJSON() 以 JSON 数据格式返回日期字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleString() 据本地时间格式，把 Date 对象转换为字符串。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。","tags":[]},{"title":"常用电脑快捷键","date":"2017-07-04T02:25:55.000Z","path":"2017/07/04/常用电脑快捷键/","text":"习惯了鼠标的运用，对于键盘本身却并不是特别了解，在这里，整理了一些常用的快捷键帮助自己更好的使用电脑。 从所有快捷键中整理出的自己常用的快捷键 WIN 显示或隐藏“开始”菜单WIN + D 显示桌面WIN + M 最小化所有窗口 //我认为和WIN + D大同小异WIN + SHIFt + M 还原最小化的窗口WIN + E 打开“我的电脑”WIN + R 打开“运行”对话框Ctrl + A 选中全部内容Ctrl + C 复制Ctrl + X 剪切Ctrl + V 粘贴Ctrl + Z 撤消Ctrl + W 关闭程序Ctrl + F4 关闭当前页面DELETE 删除Shift + Delete 永久删除所选项，而不将它放在‘回收站’中Alt + F4 关闭当前项目或退出程序Alt + Tab在打开的项目之中进行切换F5刷新当前窗口Shift + F5 强制刷新 常用电脑快捷键 F1显示程序或系统帮助内容F2重新命名所选项目F3搜索文件或文件夹F5刷新当前窗口F6循环切换屏幕元素F10激活当前程序中的菜单条Ctrl + A 选中全部内容Ctrl + C 复制Ctrl + X 剪切Ctrl + V 粘贴Ctrl + Z 撤消Ctrl + Esc 显示“开始”菜单Alt + Enter 查看所选项目的属性Alt + F4 关闭当前项目或退出程序Alt + 空格键 为当前窗口打开快捷菜单Alt + Tab 在打开的项目之间切换Alt + Esc 以项目打开的顺序循环切换DELETE删除Shift + Delete 永久删除所选项Shift + F10 显示所选项的快捷菜单Esc取消当前任务ctrl + alt + delete 电脑锁屏快捷键电脑：print screen sysrq 在键盘右上角一般靠近F12键截图qq：ctrl + alt + A 截图360浏览器：Ctrl + Shift + X 截图 Ctrl快捷键 Ctrl + S 保存Ctrl + W 关闭程序Ctrl + N 新建Ctrl + O 打开Ctrl + Z 撤销Ctrl + F 查找Ctrl + X剪切Ctrl + C 复制Ctrl + V 粘贴Ctrl + A 全选Ctrl + [ 缩小文字Ctrl + [ 缩小文字Ctrl + ] 放大文字Ctrl + B 粗体Ctrl + I 斜体Ctrl + U 下划线Ctrl + Shift 输入法切换Ctrl + 空格 中英文切换Ctrl + 回车 QQ号中发送信息Ctrl + Home 光标快速移到文件头Ctrl + End 光标快速移到文件尾Ctrl + Esc 显示开始菜单Ctrl + Shift+ 快速放大文字Ctrl + F5 在IE中强行刷新Ctrl + 拖动文件 启动\\关闭输入法Ctrl + Shift + 拖动文件 创建快捷方式 Alt快捷键 Alt + F4 关闭当前程序Alt + 空格 + C 关闭窗口Alt + 空格 + N 最小化当前窗口Alt + 空格 + R 恢复最小化窗口Alt + 空格 + X 最大化当前窗口Alt + 空格 + M 移动窗口Alt + 空格 + S 改变窗口大小Alt + Tab 两个程序交换Alt + F 打开文件菜单Alt + V 打开视图菜单Alt + E 打开编辑菜单Alt + I 打开插入菜单Alt + O 打开格式菜单Alt + T 打开工具菜单Alt + A 打开表格菜单Alt + W 打开窗口菜单Alt + H 打开帮助菜单Alt + 回车 查看文件属性Alt + 双击文件 查看文件属性Shift + 空格 半\\全角切换Shift + 右击右菜单 打开方式Shift + F10 选中文件的右菜单Shift + 多级文件 全部关闭Shift + Del 直接删除文件 对话框快捷键 Ctrl + Tab 在选项卡之间向前移动Ctrl + Shift + Tab 在选项卡之间向后移动Shift + Tab 在选项之间向后移动ALT + 带下划线的字母 执行相应的命令或选中相应的选项Enter执行活选项动或按钮所对应的命令space空格键如果活选项动是复选框，则选中或清除该复选框F1显示帮助F4显示当前列表中的项目BackSpace如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹 辅助键盘快捷键 右侧SHIFT键八秒钟切换“筛选键”的开和关左边的ALT + 左边的SHIFT + PRINTSCREEN切换“高对比度”的开和关左边的ALT + 左边的SHIFT + NUMLOCK切换“鼠标键”的开和关Shift键五次切换“粘滞键”的开和关NumLock键五秒钟切换“切换键”的开和关Alt + Shift + + 扩展标题下的文本Alt + Shift + - 折叠标题下的文本Alt + Shift + A 扩展或折叠所有文本或标题数字键盘上的斜杠（/）隐藏或显示字符格式Alt + Shift + L 只显示首行正文或显示全部正文Alt + Shift + 1 显示所有具有”标题1”样式的标题Alt + Shift + n 显示从”标题1”到”标题n”的“Windows资源管理器”键盘快捷键END显示当前窗口的底端Home显示当前窗口的顶端NUMLOCK + 数字键盘的星号(*) 显示所选文件夹的所有子文件夹NUMLOCK + 数字键盘的加号( + ) 显示所选文件夹的内容NUMLOCK + 数字键盘的减号(-) 折叠所选的文件夹单独按Windows：显示或隐藏“开始”功能表Windows + BREAK 显示“系统属性”对话框Windows + D 显示桌面Windows + M 最小化所有窗口Windows + Shift + M 还原最小化的窗口Windows + E 开启“资源管理器”Windows + F 查找文件或文件夹Windows + CTRL + F 查找电脑Windows + F1 显示Windows“帮助”Windows + R 运行Windows + U 开启“公用程序管理器”Windows + L 切换使用者","tags":[]},{"title":"working copy locked 问题","date":"2017-06-29T06:10:10.000Z","path":"2017/06/29/working-copy-locked-问题/","text":"SVN本地更新时，由于一些操作中断更新，如磁盘空间不够，用户取消，可能会造成本地文件被锁定的情况。一般出现这种情况的解决方法：１、可以使用SVN clean up来清除锁定。 ２、如果不是本目录锁定，系统提示上一层目录锁定，需要到上一层或者根目录中清除。 ３.如果在根目录下都无法clean的话，一般采取的方法是另外找一个目录重新CHECKOUT。但有时有时SVN目录下可能有一些自己本地修改的文件，还未提交到SVN服务器，这时重新CHECKOUT需要注意本地文件的备份，并且不要强制覆盖服务器上其它人修改的内容。 ４.如果觉得第３种很麻烦，可以考虑这样的方法。其实SVN加锁会在.SVN（隐藏文件）中生成一个名字叫lock的文件（无后缀），查找所有的，手工删除。然后再尝试更新，系统可能会提示某个.base文件无法访问。找到它，把相关的文件或其所在的目录删除，重新UPDATE。工作量就小多了。 解决svn的working copy locked并且cleanup恢复不能的情况产生这种情况大多是因为上次svn命令执行失败且被锁定了。如果clean up没有效果的话只好手动删除锁定文件。cd 到svn项目目录下，然后执行如下命令del lock /q/s就把锁删掉了。","tags":[]},{"title":"微信小程序——400报错","date":"2017-06-23T02:26:27.000Z","path":"2017/06/23/微信小程序/","text":"最近一直跟着demo做小程序，但是刚开始就卡在了请求豆瓣电影API数据上，折腾了很久才发现问题，初始请求数据代码如下：1234567891011121314wx.request(&#123; url: 'http://api.douban.com/v2/movie/top250', method: 'GET', data: &#123;&#125;, header: &#123; 'Accept': 'application/json' &#125;, success: function(res) &#123; console.log(res); that.setData(&#123; movieList: res &#125;) &#125;&#125;) 但是请求之后总是报400错误:后来才发现，小程序升级之后，数据请求的header写法已经变了，需要修改请求头部1234567891011121314 wx.request(&#123; url: 'http://api.douban.com/v2/movie/top250', method: 'GET', data: &#123;&#125;, header: &#123; \"Content-Type\":\"json\" &#125;, success: function(res) &#123; console.log(res); that.setData(&#123; movieList: res &#125;) &#125;&#125;) 改成这样之后就OK了。","tags":[]},{"title":"VUE简单教程","date":"2017-06-20T08:17:38.000Z","path":"2017/06/20/VUE简单教程/","text":"在使用vue.js构建大型项目时建议使用NPM安装 安装webpack1npm install webpack -g 安装vue1234# 最新稳定版本$ npm install vue# 最新稳定兼容版本$ npm install vue@csp 安装vue cli，执行以下命令安装vue cli1npm install -g vue-cli 安装完vue-cli之后，我们就可以基于vue-webpack-simple模板和vue-webpack模板创建项目了在硬盘上找一个文件夹放工程用，在终端中进入该目录 根据模板创建项目123vue init webpack-simple 工程名字&lt;工程名字不能用中文&gt;或者创建vue1.0的项目vue init webpack-simple#1.0 工程名字&lt;工程名字不能用中文&gt; 在创建模板的时候会有一些初始化的设置： Target directory exists. Continue? (Y/n) 直接回车默认(然后会下载 vue2.0模板，这里可能需要连代理) Project name (vue-test) 直接回车默认 Project description (A Vue.js project) 直接回车默认 Author 写你自己的名字 cd 命令进入创建的工程目录并安装项目依赖在做项目时经常用到的是路由模块vue-router和网络请求模块vue-resource1npm install vue-router vue-resource --save 启动项目1npm run dev","tags":[]},{"title":"浅析解决跨域问题的几种方法","date":"2017-06-08T07:45:17.000Z","path":"2017/06/08/浅析解决跨域问题的几种方法/","text":"一、JSONP 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源(域名、协议、端口)的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding(内填充)，顾名思义，就是把JSON填充到一个盒子里 javascript 代码 1234567891011121314151617createJs(sUrl)&#123; var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript); &#125; createJs('jsonp.js'); box(&#123; 'name': 'test' &#125;); function box(json)&#123; alert(json.name); &#125; 二、CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 三、通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 四、使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 五、使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。","tags":[]},{"title":"Git","date":"2017-06-06T08:59:47.000Z","path":"2017/06/06/Git/","text":"当了这么长时间的程序员，突然发现对于Git好像不太会用，在这里，让我们一起学习一下Git的使用方法吧。 Git初始化Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。使用当前目录作为Git仓库，我们只需使它初始化。 使用当前目录作为Git仓库，我们只需使它初始化。该命令执行完后会在当前目录生成一个 .git 目录。 1git init 使用我们指定目录作为Git仓库。 1git init newrepo 初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 123$ git add *.c$ git add README$ git commit -m '初始化项目版本' 添加文件首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 我在版本库newrepo目录下新建一个记事本文件 readme.txt 内容如下：11111111 第一步：使用命令 git add readme.txt添加到暂存区里面去。如下1$ git add readme.txt 用命令 git commit告诉Git，把文件提交到仓库。后面的是内容提示，可加可不加1$ git commit -m '提交test.txt文件' 现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下： 1$ git status 如果文件有改动知，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。 版本控制如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为33333333333333.并按照上述步骤进行提交。 现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示： 1$ git log git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下： 1$ git log –pretty=oneline 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。如果想回退到上一个版本的命令如下操作： 1$ git reset --hard HEAD^ 1$ git reset --hard HEAD~100 再来查看下 readme.txt内容如下：通过命令cat readme.txt查看 1$ cat readme.txt 我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下： 1$ git reflog 通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令git reset –hard 6fcfc89来恢复了。演示如下： 1$ git reset --hard 6fcfc89 可以看到 目前已经是最新的版本了。","tags":[]},{"title":"BlueLake博客主题的详细配置","date":"2017-05-25T03:41:18.000Z","path":"2017/05/25/BlueLake博客主题的详细配置/","text":"BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口： git bash 1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。 12$ npm install hexo-renderer-jade --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake) 1theme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式： 1$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。 12cd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到： 1234title: subtitle: description:about: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。","tags":[]},{"title":"缓存","date":"2017-05-24T09:43:48.000Z","path":"2017/05/24/newBlog/","text":"前端用到的的缓存一般有三种Cookie, LocalStorage 与 SessionStorage CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 LocalStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 SessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。","tags":[]},{"title":"Hexo 介绍","date":"2017-05-24T09:04:57.390Z","path":"2017/05/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]