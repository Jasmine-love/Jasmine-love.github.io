[{"title":"New Date的属性","date":"2017-07-04T07:02:04.000Z","path":"2017/07/04/New-Date的属性/","text":"在写代码用到时间的时候经常记不住获取时、分、秒等的属性怎么写，因此在这里将他们整理出来，方便查询。 时间用法表格 产品 价格 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getYear() 已废弃。 请使用 getFullYear() 方法代替。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setTime() setTime() 方法以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCSeconds() setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。 setYear() 已废弃。请使用 setFullYear() 方法代替。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 已废弃。请使用 toUTCString() 方法代替。 toISOString() 使用 ISO 标准返回字符串的日期格式。 toJSON() 以 JSON 数据格式返回日期字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleString() 据本地时间格式，把 Date 对象转换为字符串。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。","tags":[]},{"title":"常用电脑快捷键","date":"2017-07-04T02:25:55.000Z","path":"2017/07/04/常用电脑快捷键/","text":"习惯了鼠标的运用，对于键盘本身却并不是特别了解，在这里，整理了一些常用的快捷键帮助自己更好的使用电脑。 从所有快捷键中整理出的自己常用的快捷键 WIN 显示或隐藏“开始”菜单WIN + D 显示桌面WIN + M 最小化所有窗口 //我认为和WIN + D大同小异WIN + SHIFt + M 还原最小化的窗口WIN + E 打开“我的电脑”WIN + R 打开“运行”对话框Ctrl + A 选中全部内容Ctrl + C 复制Ctrl + X 剪切Ctrl + V 粘贴Ctrl + Z 撤消Ctrl + W 关闭程序Ctrl + F4 关闭当前页面DELETE 删除Shift + Delete 永久删除所选项，而不将它放在‘回收站’中Alt + F4 关闭当前项目或退出程序Alt + Tab在打开的项目之中进行切换F5刷新当前窗口Shift + F5 强制刷新 常用电脑快捷键 F1显示程序或系统帮助内容F2重新命名所选项目F3搜索文件或文件夹F5刷新当前窗口F6循环切换屏幕元素F10激活当前程序中的菜单条Ctrl + A 选中全部内容Ctrl + C 复制Ctrl + X 剪切Ctrl + V 粘贴Ctrl + Z 撤消Ctrl + Esc 显示“开始”菜单Alt + Enter 查看所选项目的属性Alt + F4 关闭当前项目或退出程序Alt + 空格键 为当前窗口打开快捷菜单Alt + Tab 在打开的项目之间切换Alt + Esc 以项目打开的顺序循环切换DELETE删除Shift + Delete 永久删除所选项Shift + F10 显示所选项的快捷菜单Esc取消当前任务ctrl + alt + delete 电脑锁屏快捷键电脑：print screen sysrq 在键盘右上角一般靠近F12键截图qq：ctrl + alt + A 截图360浏览器：Ctrl + Shift + X 截图 Ctrl快捷键 Ctrl + S 保存Ctrl + W 关闭程序Ctrl + N 新建Ctrl + O 打开Ctrl + Z 撤销Ctrl + F 查找Ctrl + X剪切Ctrl + C 复制Ctrl + V 粘贴Ctrl + A 全选Ctrl + [ 缩小文字Ctrl + [ 缩小文字Ctrl + ] 放大文字Ctrl + B 粗体Ctrl + I 斜体Ctrl + U 下划线Ctrl + Shift 输入法切换Ctrl + 空格 中英文切换Ctrl + 回车 QQ号中发送信息Ctrl + Home 光标快速移到文件头Ctrl + End 光标快速移到文件尾Ctrl + Esc 显示开始菜单Ctrl + Shift+ 快速放大文字Ctrl + F5 在IE中强行刷新Ctrl + 拖动文件 启动\\关闭输入法Ctrl + Shift + 拖动文件 创建快捷方式 Alt快捷键 Alt + F4 关闭当前程序Alt + 空格 + C 关闭窗口Alt + 空格 + N 最小化当前窗口Alt + 空格 + R 恢复最小化窗口Alt + 空格 + X 最大化当前窗口Alt + 空格 + M 移动窗口Alt + 空格 + S 改变窗口大小Alt + Tab 两个程序交换Alt + F 打开文件菜单Alt + V 打开视图菜单Alt + E 打开编辑菜单Alt + I 打开插入菜单Alt + O 打开格式菜单Alt + T 打开工具菜单Alt + A 打开表格菜单Alt + W 打开窗口菜单Alt + H 打开帮助菜单Alt + 回车 查看文件属性Alt + 双击文件 查看文件属性Shift + 空格 半\\全角切换Shift + 右击右菜单 打开方式Shift + F10 选中文件的右菜单Shift + 多级文件 全部关闭Shift + Del 直接删除文件 对话框快捷键 Ctrl + Tab 在选项卡之间向前移动Ctrl + Shift + Tab 在选项卡之间向后移动Shift + Tab 在选项之间向后移动ALT + 带下划线的字母 执行相应的命令或选中相应的选项Enter执行活选项动或按钮所对应的命令space空格键如果活选项动是复选框，则选中或清除该复选框F1显示帮助F4显示当前列表中的项目BackSpace如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹 辅助键盘快捷键 右侧SHIFT键八秒钟切换“筛选键”的开和关左边的ALT + 左边的SHIFT + PRINTSCREEN切换“高对比度”的开和关左边的ALT + 左边的SHIFT + NUMLOCK切换“鼠标键”的开和关Shift键五次切换“粘滞键”的开和关NumLock键五秒钟切换“切换键”的开和关Alt + Shift + + 扩展标题下的文本Alt + Shift + - 折叠标题下的文本Alt + Shift + A 扩展或折叠所有文本或标题数字键盘上的斜杠（/）隐藏或显示字符格式Alt + Shift + L 只显示首行正文或显示全部正文Alt + Shift + 1 显示所有具有”标题1”样式的标题Alt + Shift + n 显示从”标题1”到”标题n”的“Windows资源管理器”键盘快捷键END显示当前窗口的底端Home显示当前窗口的顶端NUMLOCK + 数字键盘的星号(*) 显示所选文件夹的所有子文件夹NUMLOCK + 数字键盘的加号( + ) 显示所选文件夹的内容NUMLOCK + 数字键盘的减号(-) 折叠所选的文件夹单独按Windows：显示或隐藏“开始”功能表Windows + BREAK 显示“系统属性”对话框Windows + D 显示桌面Windows + M 最小化所有窗口Windows + Shift + M 还原最小化的窗口Windows + E 开启“资源管理器”Windows + F 查找文件或文件夹Windows + CTRL + F 查找电脑Windows + F1 显示Windows“帮助”Windows + R 运行Windows + U 开启“公用程序管理器”Windows + L 切换使用者","tags":[]},{"title":"working copy locked 问题","date":"2017-06-29T06:10:10.000Z","path":"2017/06/29/working-copy-locked-问题/","text":"SVN本地更新时，由于一些操作中断更新，如磁盘空间不够，用户取消，可能会造成本地文件被锁定的情况。一般出现这种情况的解决方法：１、可以使用SVN clean up来清除锁定。 ２、如果不是本目录锁定，系统提示上一层目录锁定，需要到上一层或者根目录中清除。 ３.如果在根目录下都无法clean的话，一般采取的方法是另外找一个目录重新CHECKOUT。但有时有时SVN目录下可能有一些自己本地修改的文件，还未提交到SVN服务器，这时重新CHECKOUT需要注意本地文件的备份，并且不要强制覆盖服务器上其它人修改的内容。 ４.如果觉得第３种很麻烦，可以考虑这样的方法。其实SVN加锁会在.SVN（隐藏文件）中生成一个名字叫lock的文件（无后缀），查找所有的，手工删除。然后再尝试更新，系统可能会提示某个.base文件无法访问。找到它，把相关的文件或其所在的目录删除，重新UPDATE。工作量就小多了。 解决svn的working copy locked并且cleanup恢复不能的情况产生这种情况大多是因为上次svn命令执行失败且被锁定了。如果clean up没有效果的话只好手动删除锁定文件。cd 到svn项目目录下，然后执行如下命令del lock /q/s就把锁删掉了。","tags":[]},{"title":"微信小程序——400报错","date":"2017-06-23T02:26:27.000Z","path":"2017/06/23/微信小程序/","text":"最近一直跟着demo做小程序，但是刚开始就卡在了请求豆瓣电影API数据上，折腾了很久才发现问题，初始请求数据代码如下：1234567891011121314wx.request(&#123; url: 'http://api.douban.com/v2/movie/top250', method: 'GET', data: &#123;&#125;, header: &#123; 'Accept': 'application/json' &#125;, success: function(res) &#123; console.log(res); that.setData(&#123; movieList: res &#125;) &#125;&#125;) 但是请求之后总是报400错误:后来才发现，小程序升级之后，数据请求的header写法已经变了，需要修改请求头部1234567891011121314 wx.request(&#123; url: 'http://api.douban.com/v2/movie/top250', method: 'GET', data: &#123;&#125;, header: &#123; \"Content-Type\":\"json\" &#125;, success: function(res) &#123; console.log(res); that.setData(&#123; movieList: res &#125;) &#125;&#125;) 改成这样之后就OK了。","tags":[]},{"title":"VUE简单教程","date":"2017-06-20T08:17:38.000Z","path":"2017/06/20/VUE简单教程/","text":"在使用vue.js构建大型项目时建议使用NPM安装 安装webpack1npm install webpack -g 安装vue1234# 最新稳定版本$ npm install vue# 最新稳定兼容版本$ npm install vue@csp 安装vue cli，执行以下命令安装vue cli1npm install -g vue-cli 安装完vue-cli之后，我们就可以基于vue-webpack-simple模板和vue-webpack模板创建项目了在硬盘上找一个文件夹放工程用，在终端中进入该目录 根据模板创建项目123vue init webpack-simple 工程名字&lt;工程名字不能用中文&gt;或者创建vue1.0的项目vue init webpack-simple#1.0 工程名字&lt;工程名字不能用中文&gt; 在创建模板的时候会有一些初始化的设置： Target directory exists. Continue? (Y/n) 直接回车默认(然后会下载 vue2.0模板，这里可能需要连代理) Project name (vue-test) 直接回车默认 Project description (A Vue.js project) 直接回车默认 Author 写你自己的名字 cd 命令进入创建的工程目录并安装项目依赖在做项目时经常用到的是路由模块vue-router和网络请求模块vue-resource1npm install vue-router vue-resource --save 启动项目1npm run dev","tags":[]},{"title":"浅析解决跨域问题的几种方法","date":"2017-06-08T07:45:17.000Z","path":"2017/06/08/浅析解决跨域问题的几种方法/","text":"一、JSONP 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源(域名、协议、端口)的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding(内填充)，顾名思义，就是把JSON填充到一个盒子里 javascript 代码 1234567891011121314151617createJs(sUrl)&#123; var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript); &#125; createJs('jsonp.js'); box(&#123; 'name': 'test' &#125;); function box(json)&#123; alert(json.name); &#125; 二、CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 三、通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 四、使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 五、使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。","tags":[]},{"title":"Git","date":"2017-06-06T08:59:47.000Z","path":"2017/06/06/Git/","text":"当了这么长时间的程序员，突然发现对于Git好像不太会用，在这里，让我们一起学习一下Git的使用方法吧。 Git初始化Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。使用当前目录作为Git仓库，我们只需使它初始化。 使用当前目录作为Git仓库，我们只需使它初始化。该命令执行完后会在当前目录生成一个 .git 目录。 1git init 使用我们指定目录作为Git仓库。 1git init newrepo 初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 123$ git add *.c$ git add README$ git commit -m '初始化项目版本' 添加文件首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 我在版本库newrepo目录下新建一个记事本文件 readme.txt 内容如下：11111111 第一步：使用命令 git add readme.txt添加到暂存区里面去。如下1$ git add readme.txt 用命令 git commit告诉Git，把文件提交到仓库。后面的是内容提示，可加可不加1$ git commit -m '提交test.txt文件' 现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下： 1$ git status 如果文件有改动知，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。 版本控制如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为33333333333333.并按照上述步骤进行提交。 现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示： 1$ git log git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下： 1$ git log –pretty=oneline 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。如果想回退到上一个版本的命令如下操作： 1$ git reset --hard HEAD^ 1$ git reset --hard HEAD~100 再来查看下 readme.txt内容如下：通过命令cat readme.txt查看 1$ cat readme.txt 我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下： 1$ git reflog 通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令git reset –hard 6fcfc89来恢复了。演示如下： 1$ git reset --hard 6fcfc89 可以看到 目前已经是最新的版本了。","tags":[]},{"title":"BlueLake博客主题的详细配置","date":"2017-05-25T03:41:18.000Z","path":"2017/05/25/BlueLake博客主题的详细配置/","text":"BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口： git bash 1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。 12$ npm install hexo-renderer-jade --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake) 1theme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式： 1$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。 12cd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到： 1234title: subtitle: description:about: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。","tags":[]},{"title":"缓存","date":"2017-05-24T09:43:48.000Z","path":"2017/05/24/newBlog/","text":"前端用到的的缓存一般有三种Cookie, LocalStorage 与 SessionStorage CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 LocalStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 SessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。","tags":[]},{"title":"Hexo 介绍","date":"2017-05-24T09:04:57.390Z","path":"2017/05/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Grunt 自动化","date":"2017-05-05T06:51:26.000Z","path":"2017/05/05/Grunt-自动化/","text":"Grunt(文档中心https://gruntjs.com/),是一种自动化任务处理器，他就是一个工具框架，有很多插件扩展它的功能。 我学习这个也是从别人的博客上看的，当然人家的比我的详细多了，我这里基本也是粘贴复制的，在这里附上博客地址http://yujiangshui.com/grunt-basic-tutorial/，我这一篇纯粹是写给自己看的，因为记性不好，常常忘记该怎么做，因此把常用命令以博客的形式写下来，方便自己回顾。 Grunt基于Node.js，用JS开发，这样就可以借助Node.js实现跨系统平台的桌面端的操作，例如文档操作等等。此外，Grunt以及它的插件们，都作为一个包，可以用NPM安装进行管理。 所以 NPM 生成的 package.json 项目文件，里面可以记录当前项目中用到的 Grunt 插件，而 Grunt 会调用 Gruntfile.js 这个文件，解析里面的任务（task）并执行相应操作。 如果你对 Node.js、NPM 这些名词不太熟悉，建议先去搜索了解一下，因为下面的命令会涉及到它们，但是本文不会过多介绍。 安装 GruntGrunt 依赖 Node.js 所以在安装之前确保你安装了 Node.js。然后开始安装 Grunt。 实际上，安装的并不是 Grunt，而是 Grunt-cli，也就是命令行的 Grunt，这样你就可以使用 grunt 命令来执行某个项目中的 Gruntfile.js 中定义的 task 。但是要注意，Grunt-cli 只是一个命令行工具，用来执行，而不是 Grunt 这个工具本身。 安装 Grunt-cli 需要使用 NPM，使用下面一行即可在全局范围安装 Grunt-cli ，换句话说，就是你可以在任何地方执行 grunt 命令： 1npm install -g grunt-cli 这个 package.json 文件其实是 Node.js 来描述一个项目的文件，JSON 格式。生成这个文件超级简单，推荐用命令行交互式的生成一下： 打开命令行，cd gruntxx 文件夹下面，输入指令 npm init 之后，就出来很多信息，然后开始填写项目名称，填写好了之后回车即可。其实这里你一路回车下去也无妨，但是建议你细细的填一下，不明白的跳过好了。 npm init 填写项目信息1npm init 填写好了之后，查看目录就会发现生成 package.json 文件了，这样就算生成好了。 其实就是一个文件而已，你觉得这种方式麻烦，完全可以新建一个文件，然后将类似下面的代码复制进去，改一下对应选项，保存成 package.json 文件就可以：123456&#123; \"name\": \"my-project-name\", \"version\": \"0.1.0\", \"devDependencies\": &#123; &#125;&#125; 但这时我们还没有在项目文件中安装 Grunt 以及相关任务插件。 安装 Grunt 和所需要的插件一般需要用到： 合并文件：grunt-contrib-concat 语法检查：grunt-contrib-jshint Scss 编译：grunt-contrib-sass Less 编译：grunt-contrib-less 压缩文件：grunt-contrib-uglify 监听文件变动：grunt-contrib-watch 建立本地服务器：grunt-contrib-connect 它们的命名和文档都很规范，因为这些是官方提供的比较常用的插件。这些插件同时都是 NPM 管理的包，比如 grunt-contrib-concat - npm 你也可以在这上面看到用法等。 下面我们就要在这个项目中安装这些插件，执行命令：1npm install grunt --save-dev 表示通过 npm 安装了 grunt 到当前项目，同时加上了 –save-dev 参数，表示会把刚安装的东西添加到 package.json 文件中。不信你打开 package.json 文件看下，是不是多了123\"devDependencies\": &#123; \"grunt\": \"^0.4.5\"&#125; 没错，这个的意思就是当前项目依赖 grunt，后面是它的版本，咱们不用管。如果安装的时候没有添加 –save-dev 参数，这里就不会出现了，你需要自行添加上去。 下面我们来安装 Grunt 的插件，当然，不需要一个个的安装，太麻烦了，我们可以：123npm install -g grunt-contrib-concat grunt-contrib-jshint grunt-contrib-sass grunt-contrib-uglify grunt-contrib-watch grunt-contrib-connect grunt-contrib-less grunt-contrib-cssminnpm install --save-dev grunt-contrib-concat grunt-contrib-jshint grunt-contrib-sass grunt-contrib-uglify grunt-contrib-watch grunt-contrib-connect grunt-contrib-less grunt-contrib-cssmin 配置 Gruntfile.js 的语法插件也装好了，开始写任务吧！既然是要程序来读取执行，必要要有一定的语法规范，下面来简单的说一下： 首先要明白，这是一个 JS 文件，你可以写任意的 JS 代码，比如声明一个 对象 来存储一会要写任务的参数，或者是一个变量当作开关等等。 然后，所有的代码要包裹在123module.exports = function(grunt) &#123; ...&#125;; 里面。没有为什么。 在这里面的代码，除去你自己写的乱七八糟的 JS，与 Grunt 有关的主要有三块代码：任务配置代码、插件加载代码、任务注册代码。 顾名思义，这三块代码，任务配置代码就是调用插件配置一下要执行的任务和实现的功能，插件加载代码就是把需要用到的插件加载进来，任务注册代码就是注册一个 task，里面包含刚在前面编写的任务配置代码。 这样，就可以用 grunt 来执行注册的一个 task 从而根据任务配置代码调用需要的插件来执行相应的操作。 下面来分别看一下这三块代码的写法。 任务配置代码我就不一一配置了，这是我最后配置完成后的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113module.exports = function(grunt) &#123; var sassStyle = 'expanded'; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), sass: &#123; // sass转译 output : &#123; options: &#123; style: sassStyle &#125;, files: &#123; './scss/style.css': './scss/style.scss' &#125; &#125; &#125;, less: &#123; development: &#123; // less转译 src: ['./less/user.less'], dest: './less/global.css', &#125; &#125;, concat: &#123; //文件合并 cssDist: &#123; src: ['./css/*.css'], dest: './style/global.css', &#125;, dist: &#123; src: ['./src/*.js'], dest: './scripts/global.js', &#125;, &#125;, cssmin: &#123; // css压缩 options: &#123; keepSpecialComments: 0 &#125;, compress: &#123; files: &#123; './style/default.min.css': [ \"css/css.css\", \"css/commen.css\" ] &#125; &#125; &#125;, uglify: &#123; // Js 压缩 compressjs: &#123; files: &#123; './scripts/global.min.js': ['./scripts/global.js'] &#125; &#125; &#125;, jshint: &#123; // 语法检查 all: ['./scripts/global.js'] &#125;, watch: &#123; // 实时监听 scripts: &#123; files: ['./src/plugin.js','./src/plugin2.js'], tasks: ['concat','uglify'] &#125;, sass: &#123; files: ['./scss/style.scss'], tasks: ['sass'] &#125;, css: &#123; files: ['./css/*.css'], tasks: ['concat'] &#125;, livereload: &#123; options: &#123; livereload: '&lt;%= connect.options.livereload %&gt;' &#125;, files: [ 'index.html', './scss/style.css', './scripts/global.min.js' ] &#125; &#125;, connect: &#123; options: &#123; port: 9000, open: true, livereload: 35729, // Change this to '0.0.0.0' to access the server from outside hostname: 'localhost' &#125;, server: &#123; options: &#123; port: 9001, base: './' &#125; &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-sass'); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.loadNpmTasks('grunt-contrib-less'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-contrib-connect'); grunt.registerTask('outputcss',['sass']); grunt.registerTask('concatjs',['concat']); grunt.registerTask('compressjs',['concat','uglify']); grunt.registerTask('watchit',['sass','concat','uglify','connect','watch']); grunt.registerTask('default',['sass','less','concat','cssmin','uglify','connect','watch']);&#125;; 添加了 connect 任务，用来新建一个本地服务器，以当前目录作为服务器根目录，然后添加 watch 任务，监听 Scss 文件变动，如果变了，执行一下 sass 任务，监听JS，css，如果变了，执行 合并、检查、压缩 任务，监听 html、css、js 文件，如果变动，livereload 自动刷新打开的页面。 而注册的 watchit task 就是我们的终极 task，第一次执行，先编译 sass、再合并、检查、压缩、开启服务器、监听文件变动。我们执行一下 grunt watchit 就可以看到效果了，你可以修改一下 scss 文件，把字体设置大一点，切换到浏览器的时候，就看到了实时刷新效果。也可以修改一下 JS，故意改错一下，会发现 jshint 会提示你出错了。 项目文件传输与协作项目开发完成之后，往往需要 push 到 Github 或者上传 FTP 等。或许其他人会接手你的项目继续开发，或者你会换台电脑进行开发。 当小明用 git 上传 Github 的时候，傻了眼，项目里 node_modules 文件夹下面的东西要十几M呢，这比我项目本身还大，上传下载都不方便。 其实这些插件和 grunt 不需要上传，因为有 package.json 这个文件记录了你这个项目中依赖的 grunt 插件，你只需要上传这个文件即可。下载下来之后，只需要在这个项目文件夹下面，输入命令 npm install，NPM 会自动读取 package.json 文件，将 grunt 和有关插件给你下载下来，很方便的。 也不需要在本地上传的时候删除，用 git 的话，可以使用 .gitignore 文件来过滤掉这个文件夹，禁止 git 追踪。 总结与扩展阅读Grunt 就是这样一种任务自动运行器，应用好它可以减轻很多不必要的人工操作，只需要专注 coding 就可以。甚至还有Grunt 插件帮你自动完成 CSS Sprite，更多功能还需要你自己去摸索。 新手看完本文，再看一下 Grunt 官方文档 应该没有太多疑问了，那就再看一遍把。当然也有中文版。 除了 Grunt 之外，同类型比较火的还有 Gulp 这个工具。其实两个东西的功能是一样的，只不过是任务配置 JS 的语法不同，Gulp 的 Gulpfile.js 的写法更加通俗易懂，上手更快。但是 Gulp 的插件等感觉不如 Grunt，Grunt 官方提供了一些常见的插件，满足大部分日常工作，而且可靠值得信赖，而 Gulp 好像没有太多官方出品，各种插件不太规范。简单的说，Grunt 和 Gulp 就像 iPhone 与 Android 一样，一个质量高学习难一点，一个学起来简单但是有点那个，你懂得。 此外，可以看一些高手的项目，你会发现更好的 Grunt 用法，比如 Yeoman 生成的项目，就有很完善的 Grunt 任务和插件，此外，jQuery 等也用 Grunt 进行打包，这些 Grunt 文件你都可以查看研究一下他们的写法和用法，受益匪浅。 最后，如果你懒得跟着文章一点点的配置示例项目，你也可以跳转到示例项目的 grunt 分支，这里面是我配置好的，你需要先 npm install 然后就可以直接执行那些命令。","tags":[]}]